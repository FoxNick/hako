using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace HakoJS.SourceGenerator;

public partial class JSBindingGenerator
{
    #region Marshalable Binding Generation

    private static string GenerateMarshalableBinding(MarshalableModel model)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using HakoJS.SourceGeneration;");
        sb.AppendLine();
        if (!string.IsNullOrEmpty(model.SourceNamespace)) sb.AppendLine($"namespace {model.SourceNamespace};");

        sb.AppendLine();
        sb.AppendLine(
            $"partial {model.TypeKind} {model.TypeName} : global::HakoJS.SourceGeneration.IDefinitelyTyped<{model.TypeName}>");
        sb.AppendLine("{");
        sb.AppendLine("    public static string TypeDefinition");
        sb.AppendLine("    {");
        sb.AppendLine("        get");
        sb.AppendLine("        {");
        var escapedTypeScript = model.TypeScriptDefinition.Replace("\"", "\"\"");
        sb.AppendLine("            return @\"");
        sb.Append(escapedTypeScript);
        sb.AppendLine("\";");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    #endregion

    #region Source Output Registration

    private static void GenerateClassSource(SourceProductionContext context, ClassModel model)
    {
        var source = GenerateClassBinding(model);
        context.AddSource($"{model.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void GenerateModuleSource(SourceProductionContext context, ModuleModel model)
    {
        var source = GenerateModuleBinding(model);
        context.AddSource($"{model.ClassName}.Module.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void GenerateObjectSource(SourceProductionContext context, ObjectModel model)
    {
        var source = GenerateObjectBinding(model);
        context.AddSource($"{model.TypeName}.Object.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void GenerateMarshalableSource(SourceProductionContext context, MarshalableModel model)
    {
        if (model.IsNested)
            return;

        var source = GenerateMarshalableBinding(model);
        context.AddSource($"{model.TypeName}.Marshalable.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    #endregion

    #region Class Binding Generation

    private static string GenerateClassBinding(ClassModel model)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Concurrent;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using HakoJS.VM;");
        sb.AppendLine("using HakoJS.Builders;");
        sb.AppendLine("using HakoJS.SourceGeneration;");
        sb.AppendLine("using HakoJS.Host;");
        sb.AppendLine("using HakoJS.Extensions;");
        sb.AppendLine();
        var isNested = model.TypeSymbol?.ContainingType != null;
        if (!isNested && !string.IsNullOrEmpty(model.SourceNamespace))
            sb.AppendLine($"namespace {model.SourceNamespace};");

        sb.AppendLine();
        sb.AppendLine(
            $"partial class {model.ClassName} : global::HakoJS.SourceGeneration.IJSBindable<{model.ClassName}>, global::HakoJS.SourceGeneration.IJSMarshalable<{model.ClassName}>, global::HakoJS.SourceGeneration.IDefinitelyTyped<{model.ClassName}>");
        sb.AppendLine("{");

        GenerateCreateMethod(sb, model);
        GenerateInstanceTracking(sb, model);
        GenerateMarshalingMethods(sb, model);

        sb.AppendLine();
        sb.AppendLine("    public static string TypeDefinition");
        sb.AppendLine("    {");
        sb.AppendLine("        get");
        sb.AppendLine("        {");
        var escapedTypeScript = model.TypeScriptDefinition.Replace("\"", "\"\"");
        sb.AppendLine("            return @\"");
        sb.Append(escapedTypeScript);
        sb.AppendLine("\";");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateCreateMethod(StringBuilder sb, ClassModel model)
    {
        sb.AppendLine(
            $"    static global::HakoJS.VM.JSClass global::HakoJS.SourceGeneration.IJSBindable<{model.ClassName}>.CreatePrototype(global::HakoJS.VM.Realm realm)");
        sb.AppendLine("    {");
        sb.AppendLine(
            $"        var builder = new global::HakoJS.Builders.JSClassBuilder(realm, \"{model.JsClassName}\");");
        sb.AppendLine();

        if (model.Constructor != null)
            GenerateConstructor(sb, model);

        sb.AppendLine("        builder.SetFinalizer((runtime, opaque, classId) =>");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_instances.TryRemove(opaque, out var instance))");
        sb.AppendLine("            {");
        sb.AppendLine("                _instanceToId.TryRemove(instance, out _);");
        sb.AppendLine("            }");
        sb.AppendLine("        });");
        sb.AppendLine();

        foreach (var prop in model.Properties)
        {
            GenerateProperty(sb, model, prop);
            sb.AppendLine();
        }

        foreach (var method in model.Methods)
        {
            GenerateMethod(sb, model, method);
            sb.AppendLine();
        }

        sb.AppendLine("        var jsClass = builder.Build();");
        sb.AppendLine();
        sb.AppendLine($"        realm.Runtime.RegisterJSClass<{model.ClassName}>(jsClass);");
        sb.AppendLine(
            $"        global::HakoJS.SourceGeneration.JSMarshalingRegistry.RegisterClassReifier<{model.ClassName}>(jsClass.Id);");
        sb.AppendLine();
        sb.AppendLine("        return jsClass;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateConstructor(StringBuilder sb, ClassModel model)
    {
        sb.AppendLine("        builder.SetConstructor((ctx, instance, args, newTarget) =>");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        for (var i = 0; i < model.Constructor!.Parameters.Count; i++)
        {
            var param = model.Constructor.Parameters[i];
            GenerateParameterUnmarshaling(sb, param, i, "                ");
        }

        var paramList = string.Join(", ", model.Constructor.Parameters.Select(p => EscapeIdentifierIfNeeded(p.Name)));
        sb.AppendLine($"                var obj = new {model.ClassName}({paramList});");
        sb.AppendLine("                StoreInstance(instance, obj);");
        sb.AppendLine("            }");
        sb.AppendLine("            catch (global::System.Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                return ctx.ThrowError(ex);");
        sb.AppendLine("            }");
        sb.AppendLine("            return null;");
        sb.AppendLine("        });");
        sb.AppendLine();
    }

    private static void GenerateProperty(StringBuilder sb, ClassModel model, PropertyModel prop)
    {
        if (!prop.HasSetter)
        {
            var method = prop.IsStatic ? "AddReadOnlyStaticProperty" : "AddReadOnlyProperty";

            sb.AppendLine($"        builder.{method}(\"{prop.JsName}\",");
            sb.AppendLine("            (ctx, thisArg, args) =>");
            sb.AppendLine("            {");
            sb.AppendLine("                try");
            sb.AppendLine("                {");

            if (!prop.IsStatic)
            {
                sb.AppendLine("                    var instance = GetInstance(thisArg);");
                sb.AppendLine("                    if (instance == null)");
                sb.AppendLine(
                    "                        return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"Invalid instance\");");
                sb.AppendLine($"                    var value = instance.{prop.Name};");
            }
            else
            {
                sb.AppendLine($"                    var value = {model.ClassName}.{prop.Name};");
            }

            sb.AppendLine($"                    return {GetMarshalCode(prop.TypeInfo, "value", "ctx")};");
            sb.AppendLine("                }");
            sb.AppendLine("                catch (global::System.Exception ex)");
            sb.AppendLine("                {");
            sb.AppendLine("                    return ctx.ThrowError(ex);");
            sb.AppendLine("                }");
            sb.AppendLine("            });");
        }
        else
        {
            var method = prop.IsStatic ? "AddReadWriteStaticProperty" : "AddReadWriteProperty";

            sb.AppendLine($"        builder.{method}(\"{prop.JsName}\",");
            sb.AppendLine("            (ctx, thisArg, args) =>");
            sb.AppendLine("            {");
            sb.AppendLine("                try");
            sb.AppendLine("                {");

            if (!prop.IsStatic)
            {
                sb.AppendLine("                    var instance = GetInstance(thisArg);");
                sb.AppendLine("                    if (instance == null)");
                sb.AppendLine(
                    "                        return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"Invalid instance\");");
                sb.AppendLine($"                    var value = instance.{prop.Name};");
            }
            else
            {
                sb.AppendLine($"                    var value = {model.ClassName}.{prop.Name};");
            }

            sb.AppendLine($"                    return {GetMarshalCode(prop.TypeInfo, "value", "ctx")};");
            sb.AppendLine("                }");
            sb.AppendLine("                catch (global::System.Exception ex)");
            sb.AppendLine("                {");
            sb.AppendLine("                    return ctx.ThrowError(ex);");
            sb.AppendLine("                }");
            sb.AppendLine("            },");
            sb.AppendLine("            (ctx, thisArg, args) =>");
            sb.AppendLine("            {");
            sb.AppendLine("                if (args.Length < 1)");
            sb.AppendLine(
                $"                    return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"Property '{prop.JsName}' requires a value\");");
            sb.AppendLine("                try");
            sb.AppendLine("                {");

            GenerateValueUnmarshaling(sb, prop.TypeInfo, prop.Name, "args[0]", "                    ");

            if (!prop.IsStatic)
            {
                sb.AppendLine("                    var instance = GetInstance(thisArg);");
                sb.AppendLine("                    if (instance == null)");
                sb.AppendLine(
                    "                        return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"Invalid instance\");");
                sb.AppendLine($"                    instance.{prop.Name} = {prop.Name};");
            }
            else
            {
                sb.AppendLine($"                    {model.ClassName}.{prop.Name} = {prop.Name};");
            }

            sb.AppendLine("                    return ctx.Undefined();");
            sb.AppendLine("                }");
            sb.AppendLine("                catch (global::System.Exception ex)");
            sb.AppendLine("                {");
            sb.AppendLine("                    return ctx.ThrowError(ex);");
            sb.AppendLine("                }");
            sb.AppendLine("            });");
        }
    }

    private static void GenerateMethod(StringBuilder sb, ClassModel model, MethodModel method)
    {
        var addMethod = method.IsStatic ? "AddStaticMethod" : "AddMethod";
        var addMethodType = method.IsAsync ? addMethod + "Async" : addMethod;

        sb.AppendLine($"        builder.{addMethodType}(\"{method.JsName}\",");
        sb.AppendLine(method.IsAsync
            ? "            async (ctx, thisArg, args) =>"
            : "            (ctx, thisArg, args) =>");
        sb.AppendLine("            {");

        var requiredParams = method.Parameters.Count(p => !p.IsOptional);
        if (requiredParams > 0)
        {
            sb.AppendLine($"                if (args.Length < {requiredParams})");
            sb.AppendLine(
                $"                    return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"{method.JsName}() requires at least {requiredParams} argument(s)\");");
            sb.AppendLine();
        }

        sb.AppendLine("                try");
        sb.AppendLine("                {");

        if (!method.IsStatic)
        {
            sb.AppendLine("                    var instance = GetInstance(thisArg);");
            sb.AppendLine("                    if (instance == null)");
            sb.AppendLine(
                "                        return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"Invalid instance\");");
        }

        for (var i = 0; i < method.Parameters.Count; i++)
        {
            var param = method.Parameters[i];
            GenerateParameterUnmarshaling(sb, param, i, "                    ");
        }

        var callPrefix = method.IsStatic ? $"{model.ClassName}." : "instance.";
        var callArgs = string.Join(", ", method.Parameters.Select(p => EscapeIdentifierIfNeeded(p.Name)));

        if (method.IsAsync)
        {
            if (!method.IsVoid && method.ReturnType.SpecialType != SpecialType.System_Void)
            {
                sb.AppendLine($"                    var result = await {callPrefix}{method.Name}({callArgs});");
                sb.AppendLine($"                    return {GetMarshalCode(method.ReturnType, "result", "ctx")};");
            }
            else
            {
                sb.AppendLine($"                    await {callPrefix}{method.Name}({callArgs});");
                sb.AppendLine("                    return ctx.Undefined();");
            }
        }
        else
        {
            if (!method.IsVoid)
            {
                sb.AppendLine($"                    var result = {callPrefix}{method.Name}({callArgs});");
                sb.AppendLine($"                    return {GetMarshalCode(method.ReturnType, "result", "ctx")};");
            }
            else
            {
                sb.AppendLine($"                    {callPrefix}{method.Name}({callArgs});");
                sb.AppendLine("                    return ctx.Undefined();");
            }
        }

        sb.AppendLine("                }");
        sb.AppendLine("                catch (global::System.Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine("                    return ctx.ThrowError(ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            });");
    }

    private static void GenerateInstanceTracking(StringBuilder sb, ClassModel model)
    {
        sb.AppendLine("    private static int _nextInstanceId;");
        sb.AppendLine(
            $"    private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<int, {model.ClassName}> _instances = new();");
        sb.AppendLine(
            $"    private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<{model.ClassName}, int> _instanceToId = new();");
        sb.AppendLine();
        sb.AppendLine(
            $"    private static void StoreInstance(global::HakoJS.VM.JSValue jsValue, {model.ClassName} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (instance == null)");
        sb.AppendLine("            throw new global::System.ArgumentNullException(nameof(instance));");
        sb.AppendLine();
        sb.AppendLine("        if (!_instanceToId.TryGetValue(instance, out var id))");
        sb.AppendLine("        {");
        sb.AppendLine("            id = global::System.Threading.Interlocked.Increment(ref _nextInstanceId);");
        sb.AppendLine("            _instanceToId[instance] = id;");
        sb.AppendLine("            if (!_instances.TryAdd(id, instance))");
        sb.AppendLine("            {");
        sb.AppendLine("                _instanceToId.TryRemove(instance, out _);");
        sb.AppendLine(
            "                throw new global::System.InvalidOperationException($\"Failed to add instance with ID {id}. This should never happen.\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        jsValue.SetOpaque(id);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    private static {model.ClassName}? GetInstance(global::HakoJS.VM.JSValue jsValue)");
        sb.AppendLine("    {");
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            var id = jsValue.GetOpaque();");
        sb.AppendLine("            return _instances.TryGetValue(id, out var instance) ? instance : null;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch");
        sb.AppendLine("        {");
        sb.AppendLine("            return null;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine(
            $"    static string global::HakoJS.SourceGeneration.IJSBindable<{model.ClassName}>.TypeKey => \"{model.SourceNamespace}.{model.ClassName}\";");
        sb.AppendLine();

        sb.AppendLine(
            $"    static {model.ClassName}? global::HakoJS.SourceGeneration.IJSBindable<{model.ClassName}>.GetInstanceFromJS(global::HakoJS.VM.JSValue jsValue)");
        sb.AppendLine("    {");
        sb.AppendLine("        return GetInstance(jsValue);");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine(
            $"    static bool global::HakoJS.SourceGeneration.IJSBindable<{model.ClassName}>.RemoveInstance(global::HakoJS.VM.JSValue jsValue)");
        sb.AppendLine("    {");
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            var id = jsValue.GetOpaque();");
        sb.AppendLine("            if (_instances.TryRemove(id, out var instance))");
        sb.AppendLine("            {");
        sb.AppendLine("                _instanceToId.TryRemove(instance, out _);");
        sb.AppendLine("                return true;");
        sb.AppendLine("            }");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch");
        sb.AppendLine("        {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateMarshalingMethods(StringBuilder sb, ClassModel model)
    {
        var typeKey = $"{model.SourceNamespace}.{model.ClassName}";

        sb.AppendLine("    public global::HakoJS.VM.JSValue ToJSValue(global::HakoJS.VM.Realm realm)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var jsClass = realm.Runtime.GetJSClass<{model.ClassName}>(realm);");
        sb.AppendLine("        if (jsClass == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new global::System.InvalidOperationException(");
        sb.AppendLine($"                \"JSClass for {typeKey} has not been registered. \" +");
        sb.AppendLine($"                \"Call realm.RegisterClass<{model.ClassName}>() first.\");");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (_instanceToId.TryGetValue(this, out var existingId))");
        sb.AppendLine("        {");
        sb.AppendLine("            var jsValue = jsClass.CreateInstance(existingId);");
        sb.AppendLine("            return jsValue;");
        sb.AppendLine("        }");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine("            var jsValue = jsClass.CreateInstance();");
        sb.AppendLine("            StoreInstance(jsValue, this);");
        sb.AppendLine("            return jsValue;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine(
            $"    public static {model.ClassName} FromJSValue(global::HakoJS.VM.Realm realm, global::HakoJS.VM.JSValue jsValue)");
        sb.AppendLine("    {");
        sb.AppendLine("        var instance = GetInstance(jsValue);");
        sb.AppendLine("        if (instance == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new global::System.InvalidOperationException(");
        sb.AppendLine($"                \"JSValue does not contain a valid {typeKey} instance\");");
        sb.AppendLine("        }");
        sb.AppendLine("        return instance;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static bool IsArrayType(TypeInfo type)
    {
        // Exclude byte[] from generic array handling (it uses ArrayBuffer/TypedArray)
        if (type.FullName is "global::System.Byte[]" or "byte[]" ||
            (type.IsArray && type.ItemTypeSymbol?.SpecialType == SpecialType.System_Byte))
            return false;

        return type.IsArray;
    }

    #endregion

    #region Module Binding Generation

    private static string GenerateModuleBinding(ModuleModel model)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using HakoJS.VM;");
        sb.AppendLine("using HakoJS.Host;");
        sb.AppendLine("using HakoJS.Extensions;");
        sb.AppendLine("using HakoJS.SourceGeneration;");
        sb.AppendLine();
        if (!string.IsNullOrEmpty(model.SourceNamespace)) sb.AppendLine($"namespace {model.SourceNamespace};");

        sb.AppendLine();
        sb.AppendLine(
            $"partial class {model.ClassName} : global::HakoJS.SourceGeneration.IJSModuleBindable, global::HakoJS.SourceGeneration.IDefinitelyTyped<{model.ClassName}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public static string Name => \"{model.ModuleName}\";");
        sb.AppendLine();

        GenerateModuleCreateMethod(sb, model);

        sb.AppendLine();
        sb.AppendLine("    public static string TypeDefinition");
        sb.AppendLine("    {");
        sb.AppendLine("        get");
        sb.AppendLine("        {");
        var escapedTypeScript = model.TypeScriptDefinition.Replace("\"", "\"\"");
        sb.AppendLine("            return @\"");
        sb.Append(escapedTypeScript);
        sb.AppendLine("\";");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateModuleCreateMethod(StringBuilder sb, ModuleModel model)
    {
        sb.AppendLine(
            "    public static global::HakoJS.Host.CModule Create(global::HakoJS.Host.HakoRuntime runtime, global::HakoJS.VM.Realm? context = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        var realm = context ?? runtime.GetSystemRealm();");
        sb.AppendLine();
        sb.AppendLine($"        var module = runtime.CreateCModule(\"{model.ModuleName}\", init =>");
        sb.AppendLine("        {");

        var sortedClasses = TopologicalSortClasses(model.ClassReferences, model.Values, model.Methods);

        if (sortedClasses.Any())
        {
            foreach (var className in sortedClasses)
            {
                var classRef = model.ClassReferences.First(c => c.SimpleName == className);
                sb.AppendLine(
                    $"            var {ToCamelCase(classRef.SimpleName)}Class = realm.CreatePrototype<{classRef.FullTypeName}>();");
            }

            if (model.Values.Any() || model.Methods.Any() || model.EnumReferences.Any())
                sb.AppendLine();
        }

        foreach (var enumRef in model.EnumReferences)
        {
            sb.AppendLine($"            using var {ToCamelCase(enumRef.SimpleName)}Obj = realm.NewObject();");

            foreach (var value in enumRef.Values)
                if (enumRef.IsFlags)
                {
                    sb.AppendLine(
                        $"            using var {ToCamelCase(value.JsName)}Value = realm.NewNumber({value.Value});");
                    sb.AppendLine(
                        $"            {ToCamelCase(enumRef.SimpleName)}Obj.SetReadOnlyProperty(\"{value.GetFormattedPropertyName()}\", {ToCamelCase(value.JsName)}Value);");
                }
                else
                {
                    sb.AppendLine(
                        $"            using var {ToCamelCase(value.JsName)}Value = realm.NewString(\"{value.GetFormattedValue()}\");");
                    sb.AppendLine(
                        $"            {ToCamelCase(enumRef.SimpleName)}Obj.SetReadOnlyProperty(\"{value.GetFormattedPropertyName()}\", {ToCamelCase(value.JsName)}Value);");
                }

            sb.AppendLine($"            {ToCamelCase(enumRef.SimpleName)}Obj.Freeze(realm);");
            sb.AppendLine(
                $"            init.SetExport(\"{enumRef.ExportName}\", {ToCamelCase(enumRef.SimpleName)}Obj);");

            if (enumRef != model.EnumReferences.Last() || model.Values.Any() || model.Methods.Any())
                sb.AppendLine();
        }

        foreach (var value in model.Values)
            sb.AppendLine($"            init.SetExport(\"{value.JsName}\", {model.ClassName}.{value.Name});");

        if (model.Values.Any() && model.Methods.Any())
            sb.AppendLine();

        foreach (var method in model.Methods)
        {
            GenerateModuleMethodExport(sb, model, method);
            if (method != model.Methods.Last())
                sb.AppendLine();
        }

        if ((model.Values.Any() || model.Methods.Any() || model.EnumReferences.Any()) && sortedClasses.Any())
            sb.AppendLine();

        foreach (var className in sortedClasses)
        {
            var classRef = model.ClassReferences.First(c => c.SimpleName == className);
            sb.AppendLine($"            init.CompleteClassExport({ToCamelCase(classRef.SimpleName)}Class);");
        }

        sb.AppendLine("        }, realm)");

        var allExports = new List<string>();
        allExports.AddRange(model.Values.Select(v => v.JsName));
        allExports.AddRange(model.Methods.Select(m => m.JsName));
        allExports.AddRange(model.ClassReferences.Select(c => c.ExportName));
        allExports.AddRange(model.InterfaceReferences.Select(i => i.ExportName));
        allExports.AddRange(model.EnumReferences.Select(e => e.ExportName));

        sb.AppendLine(allExports.Any()
            ? $"            .AddExports({string.Join(", ", allExports.Select(e => $"\"{e}\""))});"
            : "            ;");

        sb.AppendLine();
        sb.AppendLine("        return module;");
        sb.AppendLine("    }");
    }

    private static List<string> TopologicalSortClasses(
        List<ModuleClassReference> classReferences,
        List<ModuleValueModel> values,
        List<ModuleMethodModel> methods)
    {
        if (classReferences.Count == 0)
            return new List<string>();

        var classNames = classReferences.Select(c => c.SimpleName).ToImmutableHashSet();
        var dependencies = new Dictionary<string, HashSet<string>>();

        foreach (var classRef in classReferences) dependencies[classRef.SimpleName] = new HashSet<string>();

        foreach (var classRef in classReferences)
        {
            var deps = ExtractTypeDependencies(classRef, classNames);
            foreach (var dep in deps)
                if (dep != classRef.SimpleName)
                    dependencies[classRef.SimpleName].Add(dep);
        }

        foreach (var value in values)
        {
            var typeName = ExtractSimpleTypeName(value.TypeInfo.FullName);
            if (classNames.Contains(typeName))
                foreach (var className in classNames)
                    if (className != typeName)
                        dependencies[className].Add(typeName);
        }

        foreach (var method in methods)
        {
            var returnTypeName = ExtractSimpleTypeName(method.ReturnType.FullName);
            if (classNames.Contains(returnTypeName))
                foreach (var className in classNames)
                    if (className != returnTypeName)
                        dependencies[className].Add(returnTypeName);

            foreach (var param in method.Parameters)
            {
                var paramTypeName = ExtractSimpleTypeName(param.TypeInfo.FullName);
                if (classNames.Contains(paramTypeName))
                    foreach (var className in classNames)
                        if (className != paramTypeName)
                            dependencies[className].Add(paramTypeName);
            }
        }

        var sorted = new List<string>();
        var visited = new HashSet<string>();
        var recursionStack = new HashSet<string>();

        foreach (var className in classNames)
            if (!visited.Contains(className))
                if (!TopologicalSortDFS(className, dependencies, visited, recursionStack, sorted))
                    return classReferences.Select(c => c.SimpleName).ToList();

        sorted.Reverse();
        return sorted;
    }

    private static bool TopologicalSortDFS(
        string node,
        Dictionary<string, HashSet<string>> dependencies,
        HashSet<string> visited,
        HashSet<string> recursionStack,
        List<string> sorted)
    {
        visited.Add(node);
        recursionStack.Add(node);

        if (dependencies.TryGetValue(node, out var deps))
            foreach (var dep in deps)
                if (!visited.Contains(dep))
                {
                    if (!TopologicalSortDFS(dep, dependencies, visited, recursionStack, sorted))
                        return false;
                }
                else if (recursionStack.Contains(dep))
                {
                    return false;
                }

        recursionStack.Remove(node);
        sorted.Add(node);
        return true;
    }

    private static HashSet<string> ExtractTypeDependencies(ModuleClassReference classRef,
        ImmutableHashSet<string> classNames)
    {
        var dependencies = new HashSet<string>();

        if (classRef.Constructor != null)
            foreach (var param in classRef.Constructor.Parameters)
            {
                var typeName = ExtractSimpleTypeName(param.TypeInfo.FullName);
                if (classNames.Contains(typeName))
                    dependencies.Add(typeName);
            }

        foreach (var prop in classRef.Properties)
        {
            var typeName = ExtractSimpleTypeName(prop.TypeInfo.FullName);
            if (classNames.Contains(typeName))
                dependencies.Add(typeName);
        }

        foreach (var method in classRef.Methods)
        {
            var returnTypeName = ExtractSimpleTypeName(method.ReturnType.FullName);
            if (classNames.Contains(returnTypeName))
                dependencies.Add(returnTypeName);

            foreach (var param in method.Parameters)
            {
                var typeName = ExtractSimpleTypeName(param.TypeInfo.FullName);
                if (classNames.Contains(typeName))
                    dependencies.Add(typeName);
            }
        }

        return dependencies;
    }

    private static string ExtractSimpleTypeName(string fullName)
    {
        var withoutGlobal = fullName.Replace("global::", "");
        var lastDot = withoutGlobal.LastIndexOf('.');
        if (lastDot >= 0)
            return withoutGlobal.Substring(lastDot + 1);
        return withoutGlobal;
    }

    private static void GenerateModuleMethodExport(StringBuilder sb, ModuleModel model, ModuleMethodModel method)
    {
        var requiredParams = method.Parameters.Count(p => !p.IsOptional);
        var methodType = method.IsAsync ? "SetFunctionAsync" : "SetFunction";

        sb.AppendLine(
            $"            init.{methodType}(\"{method.JsName}\", {(method.IsAsync ? "async " : "")}(ctx, thisArg, args) =>");
        sb.AppendLine("            {");

        if (requiredParams > 0)
        {
            sb.AppendLine($"                if (args.Length < {requiredParams})");
            sb.AppendLine(
                $"                    return ctx.ThrowError(global::HakoJS.VM.JSErrorType.Type, \"{method.JsName}() requires at least {requiredParams} argument(s)\");");
            sb.AppendLine();
        }

        sb.AppendLine("                try");
        sb.AppendLine("                {");

        for (var i = 0; i < method.Parameters.Count; i++)
        {
            var param = method.Parameters[i];
            GenerateParameterUnmarshaling(sb, param, i, "                    ");
        }

        var callArgs = string.Join(", ", method.Parameters.Select(p => EscapeIdentifierIfNeeded(p.Name)));

        if (method.IsAsync)
        {
            if (!method.IsVoid && method.ReturnType.SpecialType != SpecialType.System_Void)
            {
                sb.AppendLine($"                    var result = await {model.ClassName}.{method.Name}({callArgs});");
                sb.AppendLine($"                    return {GetMarshalCode(method.ReturnType, "result", "ctx")};");
            }
            else
            {
                sb.AppendLine($"                    await {model.ClassName}.{method.Name}({callArgs});");
                sb.AppendLine("                    return ctx.Undefined();");
            }
        }
        else
        {
            if (!method.IsVoid)
            {
                sb.AppendLine($"                    var result = {model.ClassName}.{method.Name}({callArgs});");
                sb.AppendLine($"                    return {GetMarshalCode(method.ReturnType, "result", "ctx")};");
            }
            else
            {
                sb.AppendLine($"                    {model.ClassName}.{method.Name}({callArgs});");
                sb.AppendLine("                    return ctx.Undefined();");
            }
        }

        sb.AppendLine("                }");
        sb.AppendLine("                catch (global::System.Exception ex)");
        sb.AppendLine("                {");
        sb.AppendLine("                    return ctx.ThrowError(ex);");
        sb.AppendLine("                }");
        sb.AppendLine("            });");
    }

    #endregion

    #region Name Casing Helpers

    private enum NameCasing
    {
        None = 0,
        Camel = 1,
        Pascal = 2,
        Snake = 3,
        ScreamingSnake = 4,
        Lower = 5
    }

    private enum ValueCasing
    {
        Original = 0,
        Lower = 1,
        Upper = 2
    }

    private static string ApplyCasing(string name, NameCasing casing)
    {
        return casing switch
        {
            NameCasing.Camel => ToCamelCase(name),
            NameCasing.Pascal => ToPascalCase(name),
            NameCasing.Snake => ToSnakeCase(name),
            NameCasing.ScreamingSnake => ToScreamingSnakeCase(name),
            NameCasing.Lower => name.ToLowerInvariant(),
            _ => name
        };
    }

    private static string ApplyValueCasing(string name, ValueCasing casing)
    {
        return casing switch
        {
            ValueCasing.Lower => name.ToLowerInvariant(),
            ValueCasing.Upper => name.ToUpperInvariant(),
            _ => name
        };
    }

    private static string ToSnakeCase(string str)
    {
        if (string.IsNullOrEmpty(str))
            return str;

        var sb = new StringBuilder();
        sb.Append(char.ToLower(str[0]));

        for (var i = 1; i < str.Length; i++)
        {
            var c = str[i];
            if (char.IsUpper(c))
            {
                sb.Append('_');
                sb.Append(char.ToLower(c));
            }
            else
            {
                sb.Append(c);
            }
        }

        return sb.ToString();
    }

    private static string ToScreamingSnakeCase(string str)
    {
        if (string.IsNullOrEmpty(str))
            return str;

        var sb = new StringBuilder();
        sb.Append(char.ToUpper(str[0]));

        for (var i = 1; i < str.Length; i++)
        {
            var c = str[i];
            if (char.IsUpper(c))
            {
                sb.Append('_');
                sb.Append(c);
            }
            else
            {
                sb.Append(char.ToUpper(c));
            }
        }

        return sb.ToString();
    }

    #endregion
}