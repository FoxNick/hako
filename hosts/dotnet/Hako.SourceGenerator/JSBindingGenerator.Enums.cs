using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace HakoJS.SourceGenerator;

public partial class JSBindingGenerator
{
    #region Enum Model Extraction

    private static EnumResult GetEnumModel(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (context.TargetSymbol is not INamedTypeSymbol enumSymbol)
            return new EnumResult(null, ImmutableArray<Diagnostic>.Empty);

        var diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();

        if (enumSymbol.TypeKind != TypeKind.Enum)
            return new EnumResult(null, diagnostics.ToImmutable());

        var jsEnumName = GetJsEnumName(enumSymbol);

        var isFlags = enumSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() == "System.FlagsAttribute");

        var values = new List<EnumValueModel>();
        foreach (var member in enumSymbol.GetMembers().OfType<IFieldSymbol>())
        {
            if (member.IsImplicitlyDeclared || !member.HasConstantValue)
                continue;

            values.Add(new EnumValueModel
            {
                Name = member.Name,
                JsName = member.Name,
                Value = member.ConstantValue ?? 0,
                Documentation = ExtractXmlDocumentation(member)
            });
        }

        var documentation = ExtractXmlDocumentation(enumSymbol);
        var typeScriptDefinition = GenerateEnumTypeScriptDefinition(
            jsEnumName,
            values,
            isFlags,
            documentation);

        var model = new EnumModel
        {
            EnumName = enumSymbol.Name,
            SourceNamespace = enumSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : enumSymbol.ContainingNamespace.ToDisplayString(),
            JsEnumName = jsEnumName,
            Values = values,
            IsFlags = isFlags,
            TypeScriptDefinition = typeScriptDefinition,
            Documentation = documentation,
            DeclaredAccessibility = enumSymbol.DeclaredAccessibility
        };

        return new EnumResult(model, ImmutableArray<Diagnostic>.Empty);
    }

    private static string GetAccessibilityModifier(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "internal"
        };
    }

    #endregion

    #region Enum Binding Generation

    private static string GenerateEnumBinding(
        EnumModel model,
        (Platform Platform, OptimizationLevel OptimizationLevel, string? AssemblyName,
            Microsoft.CodeAnalysis.CSharp.LanguageVersion? LanguageVersion) compilationSettings)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using HakoJS.SourceGeneration;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(model.SourceNamespace))
            sb.AppendLine($"namespace {model.SourceNamespace};");

        sb.AppendLine();

        var accessibility = GetAccessibilityModifier(model.DeclaredAccessibility);
        var useCSharp14Extensions = compilationSettings.LanguageVersion is >= LanguageVersion.CSharp14;

        if (useCSharp14Extensions)
        {
            // Use C# 14+ extension syntax
            sb.AppendLine($"{accessibility} static class {model.EnumName}TypeDefinition");
            sb.AppendLine("{");
            sb.AppendLine($"    extension({model.EnumName})");
            sb.AppendLine("    {");
            sb.AppendLine($"        {accessibility} static string TypeDefinition");
            sb.AppendLine("        {");
            sb.AppendLine("            get");
            sb.AppendLine("            {");

            var escapedTypeScript = model.TypeScriptDefinition.Replace("\"", "\"\"");
            sb.AppendLine("                return @\"");
            sb.Append(escapedTypeScript);
            sb.AppendLine("\";");

            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
        }
        else
        {
            // Use traditional static class for compatibility
            sb.AppendLine($"{accessibility} static class {model.EnumName}TypeDefinition");
            sb.AppendLine("{");
            sb.AppendLine($"    {accessibility} static string GetTypeDefinition()");
            sb.AppendLine("    {");

            var escapedTypeScript = model.TypeScriptDefinition.Replace("\"", "\"\"");
            sb.AppendLine("        return @\"");
            sb.Append(escapedTypeScript);
            sb.AppendLine("\";");

            sb.AppendLine("    }");
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void GenerateEnumSource(
        SourceProductionContext context,
        EnumModel model,
        (Platform Platform, OptimizationLevel OptimizationLevel, string? AssemblyName, LanguageVersion? LanguageVersion)
            compilationSettings)
    {
        var source = GenerateEnumBinding(model, compilationSettings);
        context.AddSource($"{model.EnumName}.Enum.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    #endregion
}