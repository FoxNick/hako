//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Hako Version: c6fd3a9-dirty
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------




#nullable enable

using HakoJS.Backend.Core;

namespace HakoJS.Host;

internal sealed class HakoRegistry
{
    public const int NullPointer = 0;
    private readonly WasmInstance _instance;

    internal HakoRegistry(WasmInstance instance)
    {
        _instance = instance ?? throw new ArgumentNullException(nameof(instance));
        InitializeFunctions();
    }

    private void InitializeFunctions()
    {
        __initialize = TryCreateAction("_initialize");
        _throw = TryCreateFuncInt32<int, int>("HAKO_Throw");
        _throwError = TryCreateFuncInt32<int, int, int>("HAKO_ThrowError");
        _newError = TryCreateFuncInt32<int>("HAKO_NewError");
        _runtimeSetMemoryLimit = TryCreateAction<int, int>("HAKO_RuntimeSetMemoryLimit");
        _runtimeComputeMemoryUsage = TryCreateFuncInt32<int, int>("HAKO_RuntimeComputeMemoryUsage");
        _runtimeDumpMemoryUsage = TryCreateFuncInt32<int>("HAKO_RuntimeDumpMemoryUsage");
        _runtimeJSThrow = TryCreateAction<int, int>("HAKO_RuntimeJSThrow");
        _initTypeStripper = TryCreateFuncInt32<int>("HAKO_InitTypeStripper");
        _cleanupTypeStripper = TryCreateAction<int>("HAKO_CleanupTypeStripper");
        _stripTypes = TryCreateFuncInt32<int, int, int, int>("HAKO_StripTypes");
        _getUndefined = TryCreateFuncInt32("HAKO_GetUndefined");
        _getNull = TryCreateFuncInt32("HAKO_GetNull");
        _getFalse = TryCreateFuncInt32("HAKO_GetFalse");
        _getTrue = TryCreateFuncInt32("HAKO_GetTrue");
        _newRuntime = TryCreateFuncInt32("HAKO_NewRuntime");
        _freeRuntime = TryCreateAction<int>("HAKO_FreeRuntime");
        _setStripInfo = TryCreateAction<int, int>("HAKO_SetStripInfo");
        _getStripInfo = TryCreateFuncInt32<int>("HAKO_GetStripInfo");
        _newContext = TryCreateFuncInt32<int, int>("HAKO_NewContext");
        _setContextData = TryCreateAction<int, int>("HAKO_SetContextData");
        _getContextData = TryCreateFuncInt32<int>("HAKO_GetContextData");
        _freeContext = TryCreateAction<int>("HAKO_FreeContext");
        _dupValuePointer = TryCreateFuncInt32<int, int>("HAKO_DupValuePointer");
        _freeValuePointer = TryCreateAction<int, int>("HAKO_FreeValuePointer");
        _freeValuePointerRuntime = TryCreateAction<int, int>("HAKO_FreeValuePointerRuntime");
        _malloc = TryCreateFuncInt32<int, int>("HAKO_Malloc");
        _runtimeMalloc = TryCreateFuncInt32<int, int>("HAKO_RuntimeMalloc");
        _free = TryCreateAction<int, int>("HAKO_Free");
        _runtimeFree = TryCreateAction<int, int>("HAKO_RuntimeFree");
        _freeCString = TryCreateAction<int, int>("HAKO_FreeCString");
        _newObject = TryCreateFuncInt32<int>("HAKO_NewObject");
        _newObjectProto = TryCreateFuncInt32<int, int>("HAKO_NewObjectProto");
        _newArray = TryCreateFuncInt32<int>("HAKO_NewArray");
        _newArrayBuffer = TryCreateFuncInt32<int, int, int>("HAKO_NewArrayBuffer");
        _newFloat64 = TryCreateFuncInt32WithDouble<int, double>("HAKO_NewFloat64");
        _getFloat64 = TryCreateFuncDouble<int, int>("HAKO_GetFloat64");
        _newString = TryCreateFuncInt32<int, int>("HAKO_NewString");
        _toCString = TryCreateFuncInt32<int, int>("HAKO_ToCString");
        _copyArrayBuffer = TryCreateFuncInt32<int, int, int>("HAKO_CopyArrayBuffer");
        _eval = TryCreateFuncInt32<int, int, int, int, int, int>("HAKO_Eval");
        _newSymbol = TryCreateFuncInt32<int, int, int>("HAKO_NewSymbol");
        _getSymbolDescriptionOrKey = TryCreateFuncInt32<int, int>("HAKO_GetSymbolDescriptionOrKey");
        _isGlobalSymbol = TryCreateFuncInt32<int, int>("HAKO_IsGlobalSymbol");
        _isJobPending = TryCreateFuncInt32<int>("HAKO_IsJobPending");
        _executePendingJob = TryCreateFuncInt32<int, int, int>("HAKO_ExecutePendingJob");
        _getProp = TryCreateFuncInt32<int, int, int>("HAKO_GetProp");
        _getPropNumber = TryCreateFuncInt32<int, int, int>("HAKO_GetPropNumber");
        _setProp = TryCreateFuncInt32<int, int, int, int>("HAKO_SetProp");
        _defineProp = TryCreateFuncInt32<int, int, int, int, int, int, int, int, int, int, int>("HAKO_DefineProp");
        _getOwnPropertyNames = TryCreateFuncInt32<int, int, int, int, int>("HAKO_GetOwnPropertyNames");
        _call = TryCreateFuncInt32<int, int, int, int, int>("HAKO_Call");
        _getLastError = TryCreateFuncInt32<int, int>("HAKO_GetLastError");
        _dump = TryCreateFuncInt32<int, int>("HAKO_Dump");
        _getModuleNamespace = TryCreateFuncInt32<int, int>("HAKO_GetModuleNamespace");
        _typeOf = TryCreateFuncInt32<int, int>("HAKO_TypeOf");
        _isNull = TryCreateFuncInt32<int>("HAKO_IsNull");
        _isUndefined = TryCreateFuncInt32<int>("HAKO_IsUndefined");
        _isNullOrUndefined = TryCreateFuncInt32<int>("HAKO_IsNullOrUndefined");
        _getLength = TryCreateFuncInt32<int, int, int>("HAKO_GetLength");
        _isEqual = TryCreateFuncInt32<int, int, int, int>("HAKO_IsEqual");
        _getGlobalObject = TryCreateFuncInt32<int>("HAKO_GetGlobalObject");
        _newPromiseCapability = TryCreateFuncInt32<int, int>("HAKO_NewPromiseCapability");
        _isPromise = TryCreateFuncInt32<int, int>("HAKO_IsPromise");
        _promiseState = TryCreateFuncInt32<int, int>("HAKO_PromiseState");
        _promiseResult = TryCreateFuncInt32<int, int>("HAKO_PromiseResult");
        _buildIsDebug = TryCreateFuncInt32("HAKO_BuildIsDebug");
        _newFunction = TryCreateFuncInt32<int, int, int>("HAKO_NewFunction");
        _argvGetJSValueConstPointer = TryCreateFuncInt32<int, int>("HAKO_ArgvGetJSValueConstPointer");
        _runtimeEnableInterruptHandler = TryCreateAction<int, int>("HAKO_RuntimeEnableInterruptHandler");
        _runtimeDisableInterruptHandler = TryCreateAction<int>("HAKO_RuntimeDisableInterruptHandler");
        _runtimeEnableModuleLoader = TryCreateAction<int, int, int>("HAKO_RuntimeEnableModuleLoader");
        _runtimeDisableModuleLoader = TryCreateAction<int>("HAKO_RuntimeDisableModuleLoader");
        _bJSON_Encode = TryCreateFuncInt32<int, int, int>("HAKO_BJSON_Encode");
        _bJSON_Decode = TryCreateFuncInt32<int, int, int>("HAKO_BJSON_Decode");
        _isArray = TryCreateFuncInt32<int, int>("HAKO_IsArray");
        _isTypedArray = TryCreateFuncInt32<int, int>("HAKO_IsTypedArray");
        _getTypedArrayType = TryCreateFuncInt32<int, int>("HAKO_GetTypedArrayType");
        _copyTypedArrayBuffer = TryCreateFuncInt32<int, int, int>("HAKO_CopyTypedArrayBuffer");
        _isArrayBuffer = TryCreateFuncInt32<int>("HAKO_IsArrayBuffer");
        _toJson = TryCreateFuncInt32<int, int, int>("HAKO_ToJson");
        _parseJson = TryCreateFuncInt32<int, int, int, int>("HAKO_ParseJson");
        _isError = TryCreateFuncInt32<int, int>("HAKO_IsError");
        _isException = TryCreateFuncInt32<int>("HAKO_IsException");
        _setGCThreshold = TryCreateActionWithLong<int, long>("HAKO_SetGCThreshold");
        _newBigInt = TryCreateFuncInt32<int, int, int>("HAKO_NewBigInt");
        _newBigUInt = TryCreateFuncInt32<int, int, int>("HAKO_NewBigUInt");
        _newDate = TryCreateFuncInt32WithDouble<int, double>("HAKO_NewDate");
        _getClassID = TryCreateFuncInt32<int>("HAKO_GetClassID");
        _isInstanceOf = TryCreateFuncInt32<int, int, int>("HAKO_IsInstanceOf");
        _buildInfo = TryCreateFuncInt32("HAKO_BuildInfo");
        _compileToByteCode = TryCreateFuncInt32<int, int, int, int, int, int, int>("HAKO_CompileToByteCode");
        _evalByteCode = TryCreateFuncInt32<int, int, int, int>("HAKO_EvalByteCode");
        _newCModule = TryCreateFuncInt32<int, int>("HAKO_NewCModule");
        _addModuleExport = TryCreateFuncInt32<int, int, int>("HAKO_AddModuleExport");
        _setModuleExport = TryCreateFuncInt32<int, int, int, int>("HAKO_SetModuleExport");
        _getModuleName = TryCreateFuncInt32<int, int>("HAKO_GetModuleName");
        _newClassID = TryCreateFuncInt32<int>("HAKO_NewClassID");
        _newClass = TryCreateFuncInt32<int, int, int, int, int>("HAKO_NewClass");
        _setClassProto = TryCreateAction<int, int, int>("HAKO_SetClassProto");
        _setConstructor = TryCreateAction<int, int, int>("HAKO_SetConstructor");
        _newObjectClass = TryCreateFuncInt32<int, int>("HAKO_NewObjectClass");
        _setOpaque = TryCreateAction<int, int>("HAKO_SetOpaque");
        _getOpaque = TryCreateFuncInt32<int, int, int>("HAKO_GetOpaque");
        _newObjectProtoClass = TryCreateFuncInt32<int, int, int>("HAKO_NewObjectProtoClass");
        _setModulePrivateValue = TryCreateAction<int, int, int>("HAKO_SetModulePrivateValue");
        _getModulePrivateValue = TryCreateFuncInt32<int, int>("HAKO_GetModulePrivateValue");
        _newTypedArray = TryCreateFuncInt32<int, int, int>("HAKO_NewTypedArray");
        _newTypedArrayWithBuffer = TryCreateFuncInt32<int, int, int, int, int>("HAKO_NewTypedArrayWithBuffer");
        _runGC = TryCreateAction<int>("HAKO_RunGC");
        _markValue = TryCreateAction<int, int, int>("HAKO_MarkValue");
        _setPromiseRejectionHandler = TryCreateAction<int, int>("HAKO_SetPromiseRejectionHandler");
        _clearPromiseRejectionHandler = TryCreateAction<int>("HAKO_ClearPromiseRejectionHandler");
    }

    #region Function Invokers

    private Action? __initialize;
    private Func<int, int, int>? _throw;
    private Func<int, int, int, int>? _throwError;
    private Func<int, int>? _newError;
    private Action<int, int>? _runtimeSetMemoryLimit;
    private Func<int, int, int>? _runtimeComputeMemoryUsage;
    private Func<int, int>? _runtimeDumpMemoryUsage;
    private Action<int, int>? _runtimeJSThrow;
    private Func<int, int>? _initTypeStripper;
    private Action<int>? _cleanupTypeStripper;
    private Func<int, int, int, int, int>? _stripTypes;
    private Func<int>? _getUndefined;
    private Func<int>? _getNull;
    private Func<int>? _getFalse;
    private Func<int>? _getTrue;
    private Func<int>? _newRuntime;
    private Action<int>? _freeRuntime;
    private Action<int, int>? _setStripInfo;
    private Func<int, int>? _getStripInfo;
    private Func<int, int, int>? _newContext;
    private Action<int, int>? _setContextData;
    private Func<int, int>? _getContextData;
    private Action<int>? _freeContext;
    private Func<int, int, int>? _dupValuePointer;
    private Action<int, int>? _freeValuePointer;
    private Action<int, int>? _freeValuePointerRuntime;
    private Func<int, int, int>? _malloc;
    private Func<int, int, int>? _runtimeMalloc;
    private Action<int, int>? _free;
    private Action<int, int>? _runtimeFree;
    private Action<int, int>? _freeCString;
    private Func<int, int>? _newObject;
    private Func<int, int, int>? _newObjectProto;
    private Func<int, int>? _newArray;
    private Func<int, int, int, int>? _newArrayBuffer;
    private Func<int, double, int>? _newFloat64;
    private Func<int, int, double>? _getFloat64;
    private Func<int, int, int>? _newString;
    private Func<int, int, int>? _toCString;
    private Func<int, int, int, int>? _copyArrayBuffer;
    private Func<int, int, int, int, int, int, int>? _eval;
    private Func<int, int, int, int>? _newSymbol;
    private Func<int, int, int>? _getSymbolDescriptionOrKey;
    private Func<int, int, int>? _isGlobalSymbol;
    private Func<int, int>? _isJobPending;
    private Func<int, int, int, int>? _executePendingJob;
    private Func<int, int, int, int>? _getProp;
    private Func<int, int, int, int>? _getPropNumber;
    private Func<int, int, int, int, int>? _setProp;
    private Func<int, int, int, int, int, int, int, int, int, int, int, int>? _defineProp;
    private Func<int, int, int, int, int, int>? _getOwnPropertyNames;
    private Func<int, int, int, int, int, int>? _call;
    private Func<int, int, int>? _getLastError;
    private Func<int, int, int>? _dump;
    private Func<int, int, int>? _getModuleNamespace;
    private Func<int, int, int>? _typeOf;
    private Func<int, int>? _isNull;
    private Func<int, int>? _isUndefined;
    private Func<int, int>? _isNullOrUndefined;
    private Func<int, int, int, int>? _getLength;
    private Func<int, int, int, int, int>? _isEqual;
    private Func<int, int>? _getGlobalObject;
    private Func<int, int, int>? _newPromiseCapability;
    private Func<int, int, int>? _isPromise;
    private Func<int, int, int>? _promiseState;
    private Func<int, int, int>? _promiseResult;
    private Func<int>? _buildIsDebug;
    private Func<int, int, int, int>? _newFunction;
    private Func<int, int, int>? _argvGetJSValueConstPointer;
    private Action<int, int>? _runtimeEnableInterruptHandler;
    private Action<int>? _runtimeDisableInterruptHandler;
    private Action<int, int, int>? _runtimeEnableModuleLoader;
    private Action<int>? _runtimeDisableModuleLoader;
    private Func<int, int, int, int>? _bJSON_Encode;
    private Func<int, int, int, int>? _bJSON_Decode;
    private Func<int, int, int>? _isArray;
    private Func<int, int, int>? _isTypedArray;
    private Func<int, int, int>? _getTypedArrayType;
    private Func<int, int, int, int>? _copyTypedArrayBuffer;
    private Func<int, int>? _isArrayBuffer;
    private Func<int, int, int, int>? _toJson;
    private Func<int, int, int, int, int>? _parseJson;
    private Func<int, int, int>? _isError;
    private Func<int, int>? _isException;
    private Action<int, long>? _setGCThreshold;
    private Func<int, int, int, int>? _newBigInt;
    private Func<int, int, int, int>? _newBigUInt;
    private Func<int, double, int>? _newDate;
    private Func<int, int>? _getClassID;
    private Func<int, int, int, int>? _isInstanceOf;
    private Func<int>? _buildInfo;
    private Func<int, int, int, int, int, int, int, int>? _compileToByteCode;
    private Func<int, int, int, int, int>? _evalByteCode;
    private Func<int, int, int>? _newCModule;
    private Func<int, int, int, int>? _addModuleExport;
    private Func<int, int, int, int, int>? _setModuleExport;
    private Func<int, int, int>? _getModuleName;
    private Func<int, int>? _newClassID;
    private Func<int, int, int, int, int, int>? _newClass;
    private Action<int, int, int>? _setClassProto;
    private Action<int, int, int>? _setConstructor;
    private Func<int, int, int>? _newObjectClass;
    private Action<int, int>? _setOpaque;
    private Func<int, int, int, int>? _getOpaque;
    private Func<int, int, int, int>? _newObjectProtoClass;
    private Action<int, int, int>? _setModulePrivateValue;
    private Func<int, int, int>? _getModulePrivateValue;
    private Func<int, int, int, int>? _newTypedArray;
    private Func<int, int, int, int, int, int>? _newTypedArrayWithBuffer;
    private Action<int>? _runGC;
    private Action<int, int, int>? _markValue;
    private Action<int, int>? _setPromiseRejectionHandler;
    private Action<int>? _clearPromiseRejectionHandler;

    #endregion

#region Helper Methods for Creating Invokers

private Func<int, int, double>? TryCreateFuncDouble<T1, T2>(string functionName)
{
    return _instance.GetFunctionDouble<T1, T2>(functionName);
}

private Func<int>? TryCreateFuncInt32(string functionName)
{
    return _instance.GetFunctionInt32(functionName);
}

private Func<int, int, int, int, int, int, int, int, int, int, int, int>? TryCreateFuncInt32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(functionName);
}

private Func<int, int>? TryCreateFuncInt32<T1>(string functionName)
{
    return _instance.GetFunctionInt32<T1>(functionName);
}

private Func<int, int, int>? TryCreateFuncInt32<T1, T2>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2>(functionName);
}

private Func<int, double, int>? TryCreateFuncInt32WithDouble<T1, T2>(string functionName)
{
    return _instance.GetFunctionInt32WithDouble<T1, T2>(functionName);
}

private Func<int, int, int, int>? TryCreateFuncInt32<T1, T2, T3>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2, T3>(functionName);
}

private Func<int, int, int, int, int>? TryCreateFuncInt32<T1, T2, T3, T4>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2, T3, T4>(functionName);
}

private Func<int, int, int, int, int, int>? TryCreateFuncInt32<T1, T2, T3, T4, T5>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2, T3, T4, T5>(functionName);
}

private Func<int, int, int, int, int, int, int>? TryCreateFuncInt32<T1, T2, T3, T4, T5, T6>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2, T3, T4, T5, T6>(functionName);
}

private Func<int, int, int, int, int, int, int, int>? TryCreateFuncInt32<T1, T2, T3, T4, T5, T6, T7>(string functionName)
{
    return _instance.GetFunctionInt32<T1, T2, T3, T4, T5, T6, T7>(functionName);
}

private Action? TryCreateAction(string functionName)
{
    return _instance.GetAction(functionName);
}

private Action<int>? TryCreateAction<T1>(string functionName)
{
    return _instance.GetAction<T1>(functionName);
}

private Action<int, int>? TryCreateAction<T1, T2>(string functionName)
{
    return _instance.GetAction<T1, T2>(functionName);
}

private Action<int, long>? TryCreateActionWithLong<T1, T2>(string functionName)
{
    return _instance.GetActionWithLong<T1, T2>(functionName);
}

private Action<int, int, int>? TryCreateAction<T1, T2, T3>(string functionName)
{
    return _instance.GetAction<T1, T2, T3>(functionName);
}

#endregion

    #region Public API

    /// <summary></summary>
    public void _initialize()
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (__initialize == null)
                throw new InvalidOperationException("_initialize not available");
            __initialize();
        });
    }

    /// <summary>Throws an error value</summary>
    /// <param name="ctx">Context to throw in</param>
    /// <param name="error">Error value, will be duplicated and consumed by throw</param>
    public JSValuePointer Throw(JSContextPointer ctx, JSValuePointer error)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_throw == null)
                throw new InvalidOperationException("HAKO_Throw not available");
            return _throw(ctx, error);
        });
    }

    /// <summary>Throws an error with specified type and message</summary>
    /// <param name="ctx">Context to throw in</param>
    /// <param name="error_type">Error type to throw</param>
    /// <param name="message">Error message</param>
    public JSValuePointer ThrowError(JSContextPointer ctx, int error_type, int message)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_throwError == null)
                throw new InvalidOperationException("HAKO_ThrowError not available");
            return _throwError(ctx, error_type, message);
        });
    }

    /// <summary>Creates a new Error object</summary>
    /// <param name="ctx">Context to create in</param>
    public JSValuePointer NewError(JSContextPointer ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newError == null)
                throw new InvalidOperationException("HAKO_NewError not available");
            return _newError(ctx);
        });
    }

    /// <summary>Sets memory limit for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    /// <param name="limit">Limit in bytes, -1 to disable</param>
    public void RuntimeSetMemoryLimit(JSRuntimePointer rt, int limit)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeSetMemoryLimit == null)
                throw new InvalidOperationException("HAKO_RuntimeSetMemoryLimit not available");
            _runtimeSetMemoryLimit(rt, limit);
        });
    }

    /// <summary>Computes memory usage statistics</summary>
    /// <param name="rt">Runtime to query</param>
    /// <param name="ctx">Context for creating result</param>
    public JSValuePointer RuntimeComputeMemoryUsage(JSRuntimePointer rt, JSContextPointer ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeComputeMemoryUsage == null)
                throw new InvalidOperationException("HAKO_RuntimeComputeMemoryUsage not available");
            return _runtimeComputeMemoryUsage(rt, ctx);
        });
    }

    /// <summary>Dumps memory usage as string</summary>
    /// <param name="rt">Runtime to query</param>
    public int RuntimeDumpMemoryUsage(JSRuntimePointer rt)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeDumpMemoryUsage == null)
                throw new InvalidOperationException("HAKO_RuntimeDumpMemoryUsage not available");
            return _runtimeDumpMemoryUsage(rt);
        });
    }

    /// <summary>Throws a reference error</summary>
    /// <param name="ctx">Context to throw in</param>
    /// <param name="message">Error message</param>
    public void RuntimeJSThrow(JSContextPointer ctx, int message)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeJSThrow == null)
                throw new InvalidOperationException("HAKO_RuntimeJSThrow not available");
            _runtimeJSThrow(ctx, message);
        });
    }

    /// <summary>Initializes the TypeScript type stripper</summary>
    /// <param name="rt">Runtime to associate with the stripper</param>
    public int InitTypeStripper(JSRuntimePointer rt)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_initTypeStripper == null)
                throw new InvalidOperationException("HAKO_InitTypeStripper not available");
            return _initTypeStripper(rt);
        });
    }

    /// <summary>Cleans up the TypeScript type stripper</summary>
    /// <param name="rt">Runtime associated with the stripper</param>
    public void CleanupTypeStripper(JSRuntimePointer rt)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_cleanupTypeStripper == null)
                throw new InvalidOperationException("HAKO_CleanupTypeStripper not available");
            _cleanupTypeStripper(rt);
        });
    }

    /// <summary>Strips TypeScript type annotations from source code</summary>
    /// <param name="rt">Runtime to use</param>
    /// <param name="typescript_source">Input TypeScript source code. Host owns.</param>
    /// <param name="javascript_out">Output parameter for JavaScript code. Caller owns, free with HAKO_RuntimeFree.</param>
    /// <param name="javascript_len">Output parameter for JavaScript length</param>
    public int StripTypes(JSRuntimePointer rt, int typescript_source, int javascript_out, int javascript_len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_stripTypes == null)
                throw new InvalidOperationException("HAKO_StripTypes not available");
            return _stripTypes(rt, typescript_source, javascript_out, javascript_len);
        });
    }

    /// <summary>Gets pointer to undefined constant</summary>
    public JSValuePointer GetUndefined()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getUndefined == null)
                throw new InvalidOperationException("HAKO_GetUndefined not available");
            return _getUndefined();
        });
    }

    /// <summary>Gets pointer to null constant</summary>
    public JSValuePointer GetNull()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getNull == null)
                throw new InvalidOperationException("HAKO_GetNull not available");
            return _getNull();
        });
    }

    /// <summary>Gets pointer to false constant</summary>
    public JSValuePointer GetFalse()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getFalse == null)
                throw new InvalidOperationException("HAKO_GetFalse not available");
            return _getFalse();
        });
    }

    /// <summary>Gets pointer to true constant</summary>
    public JSValuePointer GetTrue()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getTrue == null)
                throw new InvalidOperationException("HAKO_GetTrue not available");
            return _getTrue();
        });
    }

    /// <summary>Creates a new runtime</summary>
    public JSRuntimePointer NewRuntime()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newRuntime == null)
                throw new InvalidOperationException("HAKO_NewRuntime not available");
            return _newRuntime();
        });
    }

    /// <summary>Frees a runtime and all associated resources</summary>
    /// <param name="rt">Runtime to free, consumed</param>
    public void FreeRuntime(JSRuntimePointer rt)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_freeRuntime == null)
                throw new InvalidOperationException("HAKO_FreeRuntime not available");
            _freeRuntime(rt);
        });
    }

    /// <summary>Configure debug info stripping for compiled code</summary>
    /// <param name="rt">Runtime to configure</param>
    /// <param name="flags">Strip flags</param>
    public void SetStripInfo(JSRuntimePointer rt, int flags)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setStripInfo == null)
                throw new InvalidOperationException("HAKO_SetStripInfo not available");
            _setStripInfo(rt, flags);
        });
    }

    /// <summary>Get debug info stripping configuration</summary>
    /// <param name="rt">Runtime to query</param>
    public int GetStripInfo(JSRuntimePointer rt)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getStripInfo == null)
                throw new InvalidOperationException("HAKO_GetStripInfo not available");
            return _getStripInfo(rt);
        });
    }

    /// <summary>Creates a new context</summary>
    /// <param name="rt">Runtime to create context in</param>
    /// <param name="intrinsics">Intrinsic flags, 0 for all standard intrinsics</param>
    public JSContextPointer NewContext(JSRuntimePointer rt, int intrinsics)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newContext == null)
                throw new InvalidOperationException("HAKO_NewContext not available");
            return _newContext(rt, intrinsics);
        });
    }

    /// <summary>Sets opaque data for context</summary>
    /// <param name="ctx">Context to configure</param>
    /// <param name="data">User data. Host owns, responsible for freeing.</param>
    public void SetContextData(JSContextPointer ctx, int data)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setContextData == null)
                throw new InvalidOperationException("HAKO_SetContextData not available");
            _setContextData(ctx, data);
        });
    }

    /// <summary>Gets opaque data from context</summary>
    /// <param name="ctx">Context to query</param>
    public int GetContextData(JSContextPointer ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getContextData == null)
                throw new InvalidOperationException("HAKO_GetContextData not available");
            return _getContextData(ctx);
        });
    }

    /// <summary>Frees a context and associated resources</summary>
    /// <param name="ctx">Context to free, consumed</param>
    public void FreeContext(JSContextPointer ctx)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_freeContext == null)
                throw new InvalidOperationException("HAKO_FreeContext not available");
            _freeContext(ctx);
        });
    }

    /// <summary>Duplicates a value, incrementing refcount</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="val">Value to duplicate</param>
    public JSValuePointer DupValuePointer(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_dupValuePointer == null)
                throw new InvalidOperationException("HAKO_DupValuePointer not available");
            return _dupValuePointer(ctx, val);
        });
    }

    /// <summary>Frees a value pointer</summary>
    /// <param name="ctx">Context that owns the value</param>
    /// <param name="val">Value to free, consumed</param>
    public void FreeValuePointer(JSContextPointer ctx, JSValuePointer val)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_freeValuePointer == null)
                throw new InvalidOperationException("HAKO_FreeValuePointer not available");
            _freeValuePointer(ctx, val);
        });
    }

    /// <summary>Frees a value pointer using runtime</summary>
    /// <param name="rt">Runtime that owns the value</param>
    /// <param name="val">Value to free, consumed</param>
    public void FreeValuePointerRuntime(JSRuntimePointer rt, JSValuePointer val)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_freeValuePointerRuntime == null)
                throw new InvalidOperationException("HAKO_FreeValuePointerRuntime not available");
            _freeValuePointerRuntime(rt, val);
        });
    }

    /// <summary>Allocates memory from context allocator</summary>
    /// <param name="ctx">Context to allocate from</param>
    /// <param name="size">Bytes to allocate</param>
    public int Malloc(JSContextPointer ctx, int size)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_malloc == null)
                throw new InvalidOperationException("HAKO_Malloc not available");
            return _malloc(ctx, size);
        });
    }

    /// <summary>Allocates memory from runtime allocator</summary>
    /// <param name="rt">Runtime to allocate from</param>
    /// <param name="size">Bytes to allocate</param>
    public int RuntimeMalloc(JSRuntimePointer rt, int size)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeMalloc == null)
                throw new InvalidOperationException("HAKO_RuntimeMalloc not available");
            return _runtimeMalloc(rt, size);
        });
    }

    /// <summary>Frees memory allocated by context</summary>
    /// <param name="ctx">Context that allocated the memory</param>
    /// <param name="ptr">Memory to free, consumed</param>
    public void Free(JSContextPointer ctx, JSMemoryPointer ptr)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_free == null)
                throw new InvalidOperationException("HAKO_Free not available");
            _free(ctx, ptr);
        });
    }

    /// <summary>Frees memory allocated by runtime</summary>
    /// <param name="rt">Runtime that allocated the memory</param>
    /// <param name="ptr">Memory to free, consumed</param>
    public void RuntimeFree(JSRuntimePointer rt, JSMemoryPointer ptr)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeFree == null)
                throw new InvalidOperationException("HAKO_RuntimeFree not available");
            _runtimeFree(rt, ptr);
        });
    }

    /// <summary>Frees a C string returned from JS</summary>
    /// <param name="ctx">Context that created the string</param>
    /// <param name="str">String to free, consumed</param>
    public void FreeCString(JSContextPointer ctx, int str)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_freeCString == null)
                throw new InvalidOperationException("HAKO_FreeCString not available");
            _freeCString(ctx, str);
        });
    }

    /// <summary>Creates a new empty object</summary>
    /// <param name="ctx">Context to create in</param>
    public JSValuePointer NewObject(JSContextPointer ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newObject == null)
                throw new InvalidOperationException("HAKO_NewObject not available");
            return _newObject(ctx);
        });
    }

    /// <summary>Creates a new object with prototype</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="proto">Prototype object</param>
    public JSValuePointer NewObjectProto(JSContextPointer ctx, JSValuePointer proto)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newObjectProto == null)
                throw new InvalidOperationException("HAKO_NewObjectProto not available");
            return _newObjectProto(ctx, proto);
        });
    }

    /// <summary>Creates a new array</summary>
    /// <param name="ctx">Context to create in</param>
    public JSValuePointer NewArray(JSContextPointer ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newArray == null)
                throw new InvalidOperationException("HAKO_NewArray not available");
            return _newArray(ctx);
        });
    }

    /// <summary>Creates an ArrayBuffer from existing memory</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="buffer">Memory buffer. Ownership transferred to JS, freed by runtime.</param>
    /// <param name="len">Buffer length in bytes</param>
    public JSValuePointer NewArrayBuffer(JSContextPointer ctx, JSMemoryPointer buffer, int len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newArrayBuffer == null)
                throw new InvalidOperationException("HAKO_NewArrayBuffer not available");
            return _newArrayBuffer(ctx, buffer, len);
        });
    }

    /// <summary>Creates a new number value</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="num">Number value</param>
    public JSValuePointer NewFloat64(JSContextPointer ctx, double num)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newFloat64 == null)
                throw new InvalidOperationException("HAKO_NewFloat64 not available");
            return _newFloat64(ctx, num);
        });
    }

    /// <summary>Converts a JavaScript value to a double</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to convert. Host owns.</param>
    public double GetFloat64(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getFloat64 == null)
                throw new InvalidOperationException("HAKO_GetFloat64 not available");
            return _getFloat64(ctx, val);
        });
    }

    /// <summary>Creates a new JavaScript string value</summary>
    /// <param name="ctx">Context</param>
    /// <param name="str">C string. Host owns.</param>
    public JSValuePointer NewString(JSContextPointer ctx, int str)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newString == null)
                throw new InvalidOperationException("HAKO_NewString not available");
            return _newString(ctx, str);
        });
    }

    /// <summary>Converts a JavaScript value to a C string</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to convert. Host owns.</param>
    public int ToCString(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_toCString == null)
                throw new InvalidOperationException("HAKO_ToCString not available");
            return _toCString(ctx, val);
        });
    }

    /// <summary>Copies data from an ArrayBuffer</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">ArrayBuffer value. Host owns.</param>
    /// <param name="out_len">Output pointer for buffer length</param>
    public int CopyArrayBuffer(JSContextPointer ctx, JSValuePointer val, int out_len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_copyArrayBuffer == null)
                throw new InvalidOperationException("HAKO_CopyArrayBuffer not available");
            return _copyArrayBuffer(ctx, val, out_len);
        });
    }

    /// <summary>Evaluates JavaScript code</summary>
    /// <param name="ctx">Context</param>
    /// <param name="js_code">JavaScript code string. Host owns.</param>
    /// <param name="js_code_len">Code length in bytes</param>
    /// <param name="filename">Filename for stack traces. Host owns.</param>
    /// <param name="detect_module">Whether to auto-detect ES module syntax</param>
    /// <param name="eval_flags">Evaluation flags (JS_EVAL_*)</param>
    public JSValuePointer Eval(JSContextPointer ctx, int js_code, int js_code_len, int filename, int detect_module, int eval_flags)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_eval == null)
                throw new InvalidOperationException("HAKO_Eval not available");
            return _eval(ctx, js_code, js_code_len, filename, detect_module, eval_flags);
        });
    }

    /// <summary>Creates a new symbol</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="description">Symbol description</param>
    /// <param name="is_global">True for global symbol (Symbol.for), false for unique</param>
    public JSValuePointer NewSymbol(JSContextPointer ctx, int description, int is_global)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newSymbol == null)
                throw new InvalidOperationException("HAKO_NewSymbol not available");
            return _newSymbol(ctx, description, is_global);
        });
    }

    /// <summary>Gets symbol description or key</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="val">Symbol to query</param>
    public int GetSymbolDescriptionOrKey(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getSymbolDescriptionOrKey == null)
                throw new InvalidOperationException("HAKO_GetSymbolDescriptionOrKey not available");
            return _getSymbolDescriptionOrKey(ctx, val);
        });
    }

    /// <summary>Checks if symbol is global</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="val">Symbol to check</param>
    public int IsGlobalSymbol(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isGlobalSymbol == null)
                throw new InvalidOperationException("HAKO_IsGlobalSymbol not available");
            return _isGlobalSymbol(ctx, val);
        });
    }

    /// <summary>Checks if promise jobs are pending</summary>
    /// <param name="rt">Runtime to check</param>
    public int IsJobPending(JSRuntimePointer rt)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isJobPending == null)
                throw new InvalidOperationException("HAKO_IsJobPending not available");
            return _isJobPending(rt);
        });
    }

    /// <summary>Executes pending promise jobs</summary>
    /// <param name="rt">Runtime to execute in</param>
    /// <param name="max_jobs_to_execute">Maximum jobs to execute, 0 for unlimited</param>
    /// <param name="out_last_job_ctx">Output parameter, set to last job's context. Can be NULL. Host borrows.</param>
    public int ExecutePendingJob(JSRuntimePointer rt, int max_jobs_to_execute, int out_last_job_ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_executePendingJob == null)
                throw new InvalidOperationException("HAKO_ExecutePendingJob not available");
            return _executePendingJob(rt, max_jobs_to_execute, out_last_job_ctx);
        });
    }

    /// <summary>Gets a property by name</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="this_val">Object to get property from</param>
    /// <param name="prop_name">Property name value</param>
    public JSValuePointer GetProp(JSContextPointer ctx, JSValuePointer this_val, JSValuePointer prop_name)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getProp == null)
                throw new InvalidOperationException("HAKO_GetProp not available");
            return _getProp(ctx, this_val, prop_name);
        });
    }

    /// <summary>Gets a property by numeric index</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="this_val">Object to get property from</param>
    /// <param name="prop_index">Property index</param>
    public JSValuePointer GetPropNumber(JSContextPointer ctx, JSValuePointer this_val, int prop_index)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getPropNumber == null)
                throw new InvalidOperationException("HAKO_GetPropNumber not available");
            return _getPropNumber(ctx, this_val, prop_index);
        });
    }

    /// <summary>Sets a property value</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="this_val">Object to set property on. Host owns.</param>
    /// <param name="prop_name">Property name value. Host owns.</param>
    /// <param name="prop_val">Property value. Host owns.</param>
    public int SetProp(JSContextPointer ctx, JSValuePointer this_val, JSValuePointer prop_name, JSValuePointer prop_val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_setProp == null)
                throw new InvalidOperationException("HAKO_SetProp not available");
            return _setProp(ctx, this_val, prop_name, prop_val);
        });
    }

    /// <summary>Defines a property with descriptor</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="this_val">Object to define property on</param>
    /// <param name="prop_name">Property name value</param>
    /// <param name="prop_val">Property value (if has_value is true)</param>
    /// <param name="getter">Getter function or undefined</param>
    /// <param name="setter">Setter function or undefined</param>
    /// <param name="configurable">Property is configurable</param>
    /// <param name="enumerable">Property is enumerable</param>
    /// <param name="has_value">Descriptor includes value</param>
    /// <param name="has_writable">Descriptor includes writable</param>
    /// <param name="writable">Property is writable (if has_writable)</param>
    public int DefineProp(JSContextPointer ctx, JSValuePointer this_val, JSValuePointer prop_name, JSValuePointer prop_val, JSValuePointer getter, JSValuePointer setter, int configurable, int enumerable, int has_value, int has_writable, int writable)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_defineProp == null)
                throw new InvalidOperationException("HAKO_DefineProp not available");
            return _defineProp(ctx, this_val, prop_name, prop_val, getter, setter, configurable, enumerable, has_value, has_writable, writable);
        });
    }

    /// <summary>Gets own property names from object</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="out_prop_ptrs">Output array of property name pointers. Caller owns, free each with HAKO_FreeValuePointer, then array with HAKO_Free.</param>
    /// <param name="out_prop_len">Output property count</param>
    /// <param name="obj">Object to enumerate</param>
    /// <param name="flags">Property enumeration flags</param>
    public JSValuePointer GetOwnPropertyNames(JSContextPointer ctx, int out_prop_ptrs, int out_prop_len, JSValuePointer obj, int flags)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getOwnPropertyNames == null)
                throw new InvalidOperationException("HAKO_GetOwnPropertyNames not available");
            return _getOwnPropertyNames(ctx, out_prop_ptrs, out_prop_len, obj, flags);
        });
    }

    /// <summary>Calls a JavaScript function</summary>
    /// <param name="ctx">Context</param>
    /// <param name="func_obj">Function to call. Host owns.</param>
    /// <param name="this_obj">This binding. Host owns.</param>
    /// <param name="argc">Argument count</param>
    /// <param name="argv_ptrs">Array of argument pointers. Host owns.</param>
    public JSValuePointer Call(JSContextPointer ctx, JSValuePointer func_obj, JSValuePointer this_obj, int argc, int argv_ptrs)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_call == null)
                throw new InvalidOperationException("HAKO_Call not available");
            return _call(ctx, func_obj, this_obj, argc, argv_ptrs);
        });
    }

    /// <summary>Gets pending exception from context</summary>
    /// <param name="ctx">Context to query</param>
    /// <param name="maybe_exception">Value to check, or NULL to get any pending exception. Host owns.</param>
    public JSValuePointer GetLastError(JSContextPointer ctx, JSValuePointer maybe_exception)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getLastError == null)
                throw new InvalidOperationException("HAKO_GetLastError not available");
            return _getLastError(ctx, maybe_exception);
        });
    }

    /// <summary>Dumps a value to string (for debugging)</summary>
    /// <param name="ctx">Context</param>
    /// <param name="obj">Value to dump. Host owns.</param>
    public int Dump(JSContextPointer ctx, JSValuePointer obj)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_dump == null)
                throw new InvalidOperationException("HAKO_Dump not available");
            return _dump(ctx, obj);
        });
    }

    /// <summary>Gets the namespace object of a module</summary>
    /// <param name="ctx">Context</param>
    /// <param name="module_func_obj">Module function. Host owns.</param>
    public JSValuePointer GetModuleNamespace(JSContextPointer ctx, JSValuePointer module_func_obj)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getModuleNamespace == null)
                throw new InvalidOperationException("HAKO_GetModuleNamespace not available");
            return _getModuleNamespace(ctx, module_func_obj);
        });
    }

    /// <summary>Gets the type of a JavaScript value</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to check. Host owns.</param>
    public int TypeOf(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_typeOf == null)
                throw new InvalidOperationException("HAKO_TypeOf not available");
            return _typeOf(ctx, val);
        });
    }

    /// <summary>Checks if a value is null</summary>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsNull(JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isNull == null)
                throw new InvalidOperationException("HAKO_IsNull not available");
            return _isNull(val);
        });
    }

    /// <summary>Checks if a value is undefined</summary>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsUndefined(JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isUndefined == null)
                throw new InvalidOperationException("HAKO_IsUndefined not available");
            return _isUndefined(val);
        });
    }

    /// <summary>Checks if a value is null or undefined</summary>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsNullOrUndefined(JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isNullOrUndefined == null)
                throw new InvalidOperationException("HAKO_IsNullOrUndefined not available");
            return _isNullOrUndefined(val);
        });
    }

    /// <summary>Gets length of array or string</summary>
    /// <param name="ctx">Context to use</param>
    /// <param name="out_len">Output length value</param>
    /// <param name="val">Object to get length from</param>
    public int GetLength(JSContextPointer ctx, int out_len, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getLength == null)
                throw new InvalidOperationException("HAKO_GetLength not available");
            return _getLength(ctx, out_len, val);
        });
    }

    /// <summary>Checks if two values are equal</summary>
    /// <param name="ctx">Context</param>
    /// <param name="a">First value. Host owns.</param>
    /// <param name="b">Second value. Host owns.</param>
    /// <param name="op">Equality operation (SameValue, SameValueZero, or StrictEqual)</param>
    public int IsEqual(JSContextPointer ctx, JSValuePointer a, JSValuePointer b, int op)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isEqual == null)
                throw new InvalidOperationException("HAKO_IsEqual not available");
            return _isEqual(ctx, a, b, op);
        });
    }

    /// <summary>Gets the global object</summary>
    /// <param name="ctx">Context to use</param>
    public JSValuePointer GetGlobalObject(JSContextPointer ctx)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getGlobalObject == null)
                throw new InvalidOperationException("HAKO_GetGlobalObject not available");
            return _getGlobalObject(ctx);
        });
    }

    /// <summary>Creates a new promise with resolve/reject functions</summary>
    /// <param name="ctx">Context</param>
    /// <param name="out_resolve_funcs">Output array [resolve, reject]. Caller owns both, free with HAKO_FreeValuePointer.</param>
    public JSValuePointer NewPromiseCapability(JSContextPointer ctx, int out_resolve_funcs)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newPromiseCapability == null)
                throw new InvalidOperationException("HAKO_NewPromiseCapability not available");
            return _newPromiseCapability(ctx, out_resolve_funcs);
        });
    }

    /// <summary>Checks if a value is a promise</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsPromise(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isPromise == null)
                throw new InvalidOperationException("HAKO_IsPromise not available");
            return _isPromise(ctx, val);
        });
    }

    /// <summary>Gets the state of a promise</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Promise value. Host owns.</param>
    public int PromiseState(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_promiseState == null)
                throw new InvalidOperationException("HAKO_PromiseState not available");
            return _promiseState(ctx, val);
        });
    }

    /// <summary>Gets the result/reason of a settled promise</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Promise value. Host owns.</param>
    public JSValuePointer PromiseResult(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_promiseResult == null)
                throw new InvalidOperationException("HAKO_PromiseResult not available");
            return _promiseResult(ctx, val);
        });
    }

    /// <summary>Checks if this is a debug build</summary>
    public int BuildIsDebug()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_buildIsDebug == null)
                throw new InvalidOperationException("HAKO_BuildIsDebug not available");
            return _buildIsDebug();
        });
    }

    /// <summary>Creates a new JavaScript function that calls back to host</summary>
    /// <param name="ctx">Context</param>
    /// <param name="func_id">Host function ID to invoke when called</param>
    /// <param name="name">Function name. Host owns.</param>
    public JSValuePointer NewFunction(JSContextPointer ctx, int func_id, int name)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newFunction == null)
                throw new InvalidOperationException("HAKO_NewFunction not available");
            return _newFunction(ctx, func_id, name);
        });
    }

    /// <summary>Gets a pointer to an argv element</summary>
    /// <param name="argv">Arguments array. Host owns.</param>
    /// <param name="index">Index to access</param>
    public JSValuePointer ArgvGetJSValueConstPointer(JSValuePointer argv, int index)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_argvGetJSValueConstPointer == null)
                throw new InvalidOperationException("HAKO_ArgvGetJSValueConstPointer not available");
            return _argvGetJSValueConstPointer(argv, index);
        });
    }

    /// <summary>Enables interrupt handler for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    /// <param name="opaque">User data passed to host handler. Host borrows.</param>
    public void RuntimeEnableInterruptHandler(JSRuntimePointer rt, int opaque)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeEnableInterruptHandler == null)
                throw new InvalidOperationException("HAKO_RuntimeEnableInterruptHandler not available");
            _runtimeEnableInterruptHandler(rt, opaque);
        });
    }

    /// <summary>Disables interrupt handler for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    public void RuntimeDisableInterruptHandler(JSRuntimePointer rt)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeDisableInterruptHandler == null)
                throw new InvalidOperationException("HAKO_RuntimeDisableInterruptHandler not available");
            _runtimeDisableInterruptHandler(rt);
        });
    }

    /// <summary>Enables module loader for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    /// <param name="use_custom_normalize">True to call host normalize function</param>
    /// <param name="opaque">User data passed to host load/normalize functions. Host borrows.</param>
    public void RuntimeEnableModuleLoader(JSRuntimePointer rt, int use_custom_normalize, int opaque)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeEnableModuleLoader == null)
                throw new InvalidOperationException("HAKO_RuntimeEnableModuleLoader not available");
            _runtimeEnableModuleLoader(rt, use_custom_normalize, opaque);
        });
    }

    /// <summary>Disables module loader for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    public void RuntimeDisableModuleLoader(JSRuntimePointer rt)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runtimeDisableModuleLoader == null)
                throw new InvalidOperationException("HAKO_RuntimeDisableModuleLoader not available");
            _runtimeDisableModuleLoader(rt);
        });
    }

    /// <summary>Encodes a value to binary JSON (QuickJS bytecode format)</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to encode. Host owns.</param>
    /// <param name="out_len">Output pointer for buffer length</param>
    public int BJSON_Encode(JSContextPointer ctx, JSValuePointer val, int out_len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_bJSON_Encode == null)
                throw new InvalidOperationException("HAKO_BJSON_Encode not available");
            return _bJSON_Encode(ctx, val, out_len);
        });
    }

    /// <summary>Decodes a value from binary JSON</summary>
    /// <param name="ctx">Context</param>
    /// <param name="buffer">Binary JSON buffer. Host owns.</param>
    /// <param name="len">Buffer length in bytes</param>
    public JSValuePointer BJSON_Decode(JSContextPointer ctx, JSMemoryPointer buffer, int len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_bJSON_Decode == null)
                throw new InvalidOperationException("HAKO_BJSON_Decode not available");
            return _bJSON_Decode(ctx, buffer, len);
        });
    }

    /// <summary>Checks if a value is an array</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsArray(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isArray == null)
                throw new InvalidOperationException("HAKO_IsArray not available");
            return _isArray(ctx, val);
        });
    }

    /// <summary>Checks if a value is a typed array</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsTypedArray(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isTypedArray == null)
                throw new InvalidOperationException("HAKO_IsTypedArray not available");
            return _isTypedArray(ctx, val);
        });
    }

    /// <summary>Gets the typed array type</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Typed array. Host owns.</param>
    public int GetTypedArrayType(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getTypedArrayType == null)
                throw new InvalidOperationException("HAKO_GetTypedArrayType not available");
            return _getTypedArrayType(ctx, val);
        });
    }

    /// <summary>Copies data from a TypedArray</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">TypedArray value. Host owns.</param>
    /// <param name="out_len">Output pointer for buffer length in bytes</param>
    public int CopyTypedArrayBuffer(JSContextPointer ctx, JSValuePointer val, int out_len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_copyTypedArrayBuffer == null)
                throw new InvalidOperationException("HAKO_CopyTypedArrayBuffer not available");
            return _copyTypedArrayBuffer(ctx, val, out_len);
        });
    }

    /// <summary>Checks if a value is an ArrayBuffer</summary>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsArrayBuffer(JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isArrayBuffer == null)
                throw new InvalidOperationException("HAKO_IsArrayBuffer not available");
            return _isArrayBuffer(val);
        });
    }

    /// <summary>Converts a value to JSON string</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to stringify. Host owns.</param>
    /// <param name="indent">Indentation level for formatting</param>
    public JSValuePointer ToJson(JSContextPointer ctx, JSValuePointer val, int indent)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_toJson == null)
                throw new InvalidOperationException("HAKO_ToJson not available");
            return _toJson(ctx, val, indent);
        });
    }

    /// <summary>Parses a JSON string</summary>
    /// <param name="ctx">Context</param>
    /// <param name="json">JSON string. Host owns.</param>
    /// <param name="json_len">String length in bytes</param>
    /// <param name="filename">Filename for error reporting. Host owns.</param>
    public JSValuePointer ParseJson(JSContextPointer ctx, int json, int json_len, int filename)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_parseJson == null)
                throw new InvalidOperationException("HAKO_ParseJson not available");
            return _parseJson(ctx, json, json_len, filename);
        });
    }

    /// <summary>Checks if a value is an Error object</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsError(JSContextPointer ctx, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isError == null)
                throw new InvalidOperationException("HAKO_IsError not available");
            return _isError(ctx, val);
        });
    }

    /// <summary>Checks if a value is an exception</summary>
    /// <param name="val">Value to check. Host owns.</param>
    public int IsException(JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isException == null)
                throw new InvalidOperationException("HAKO_IsException not available");
            return _isException(val);
        });
    }

    /// <summary>Sets GC threshold for context</summary>
    /// <param name="ctx">Context to configure</param>
    /// <param name="threshold">Threshold in bytes</param>
    public void SetGCThreshold(JSContextPointer ctx, long threshold)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setGCThreshold == null)
                throw new InvalidOperationException("HAKO_SetGCThreshold not available");
            _setGCThreshold(ctx, threshold);
        });
    }

    /// <summary>Creates a new BigInt from 64-bit signed value</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="low">Low 32 bits</param>
    /// <param name="high">High 32 bits</param>
    public JSValuePointer NewBigInt(JSContextPointer ctx, int low, int high)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newBigInt == null)
                throw new InvalidOperationException("HAKO_NewBigInt not available");
            return _newBigInt(ctx, low, high);
        });
    }

    /// <summary>Creates a new BigInt from 64-bit unsigned value</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="low">Low 32 bits</param>
    /// <param name="high">High 32 bits</param>
    public JSValuePointer NewBigUInt(JSContextPointer ctx, int low, int high)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newBigUInt == null)
                throw new InvalidOperationException("HAKO_NewBigUInt not available");
            return _newBigUInt(ctx, low, high);
        });
    }

    /// <summary>Creates a new Date object</summary>
    /// <param name="ctx">Context</param>
    /// <param name="time">Time value in milliseconds since epoch</param>
    public JSValuePointer NewDate(JSContextPointer ctx, double time)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newDate == null)
                throw new InvalidOperationException("HAKO_NewDate not available");
            return _newDate(ctx, time);
        });
    }

    /// <summary>Gets the class ID of a value</summary>
    /// <param name="val">Value to check. Host owns.</param>
    public JSClassID GetClassID(JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getClassID == null)
                throw new InvalidOperationException("HAKO_GetClassID not available");
            return _getClassID(val);
        });
    }

    /// <summary>Checks if a value is an instance of a constructor</summary>
    /// <param name="ctx">Context</param>
    /// <param name="val">Value to check. Host owns.</param>
    /// <param name="obj">Constructor/class to check against. Host owns.</param>
    public int IsInstanceOf(JSContextPointer ctx, JSValuePointer val, JSValuePointer obj)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_isInstanceOf == null)
                throw new InvalidOperationException("HAKO_IsInstanceOf not available");
            return _isInstanceOf(ctx, val, obj);
        });
    }

    /// <summary>Gets build information</summary>
    public int BuildInfo()
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_buildInfo == null)
                throw new InvalidOperationException("HAKO_BuildInfo not available");
            return _buildInfo();
        });
    }

    /// <summary>Compiles JavaScript code to bytecode</summary>
    /// <param name="ctx">Context</param>
    /// <param name="js_code">JavaScript source code. Host owns.</param>
    /// <param name="js_code_len">Code length in bytes</param>
    /// <param name="filename">Filename for error reporting. Host owns.</param>
    /// <param name="detect_module">Whether to auto-detect ES module syntax</param>
    /// <param name="flags">Compilation flags (JS_EVAL_*)</param>
    /// <param name="out_bytecode_len">Output pointer for bytecode length</param>
    public int CompileToByteCode(JSContextPointer ctx, int js_code, int js_code_len, int filename, int detect_module, int flags, int out_bytecode_len)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_compileToByteCode == null)
                throw new InvalidOperationException("HAKO_CompileToByteCode not available");
            return _compileToByteCode(ctx, js_code, js_code_len, filename, detect_module, flags, out_bytecode_len);
        });
    }

    /// <summary>Evaluates compiled bytecode</summary>
    /// <param name="ctx">Context</param>
    /// <param name="bytecode_buf">Bytecode from HAKO_CompileToByteCode. Host owns.</param>
    /// <param name="bytecode_len">Bytecode length in bytes</param>
    /// <param name="load_only">If true, loads but doesn't execute (for modules)</param>
    public JSValuePointer EvalByteCode(JSContextPointer ctx, JSMemoryPointer bytecode_buf, int bytecode_len, int load_only)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_evalByteCode == null)
                throw new InvalidOperationException("HAKO_EvalByteCode not available");
            return _evalByteCode(ctx, bytecode_buf, bytecode_len, load_only);
        });
    }

    /// <summary>Creates a new C module</summary>
    /// <param name="ctx">Context</param>
    /// <param name="name">Module name. Host owns.</param>
    public JSModuleDefPointer NewCModule(JSContextPointer ctx, int name)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newCModule == null)
                throw new InvalidOperationException("HAKO_NewCModule not available");
            return _newCModule(ctx, name);
        });
    }

    /// <summary>Adds an export declaration to a C module</summary>
    /// <param name="ctx">Context</param>
    /// <param name="mod">Module definition</param>
    /// <param name="export_name">Export name. Host owns.</param>
    public int AddModuleExport(JSContextPointer ctx, JSModuleDefPointer mod, int export_name)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_addModuleExport == null)
                throw new InvalidOperationException("HAKO_AddModuleExport not available");
            return _addModuleExport(ctx, mod, export_name);
        });
    }

    /// <summary>Sets the value of a module export</summary>
    /// <param name="ctx">Context</param>
    /// <param name="mod">Module definition</param>
    /// <param name="export_name">Export name. Host owns.</param>
    /// <param name="val">Export value. Host owns.</param>
    public int SetModuleExport(JSContextPointer ctx, JSModuleDefPointer mod, int export_name, JSValuePointer val)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_setModuleExport == null)
                throw new InvalidOperationException("HAKO_SetModuleExport not available");
            return _setModuleExport(ctx, mod, export_name, val);
        });
    }

    /// <summary>Gets the name of a module</summary>
    /// <param name="ctx">Context</param>
    /// <param name="mod">Module definition</param>
    public int GetModuleName(JSContextPointer ctx, JSModuleDefPointer mod)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getModuleName == null)
                throw new InvalidOperationException("HAKO_GetModuleName not available");
            return _getModuleName(ctx, mod);
        });
    }

    /// <summary>Allocates a new class ID</summary>
    /// <param name="out_class_id">Output pointer for the new class ID</param>
    public JSClassID NewClassID(int out_class_id)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newClassID == null)
                throw new InvalidOperationException("HAKO_NewClassID not available");
            return _newClassID(out_class_id);
        });
    }

    /// <summary>Creates and registers a new class</summary>
    /// <param name="ctx">Context</param>
    /// <param name="class_id">Class ID from HAKO_NewClassID</param>
    /// <param name="class_name">Class name. Host owns.</param>
    /// <param name="has_finalizer">Whether to call finalizer callback on GC</param>
    /// <param name="has_gc_mark">Whether to call GC mark callback</param>
    public JSValuePointer NewClass(JSContextPointer ctx, JSClassID class_id, int class_name, int has_finalizer, int has_gc_mark)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newClass == null)
                throw new InvalidOperationException("HAKO_NewClass not available");
            return _newClass(ctx, class_id, class_name, has_finalizer, has_gc_mark);
        });
    }

    /// <summary>Sets the prototype for a class</summary>
    /// <param name="ctx">Context</param>
    /// <param name="class_id">Class ID</param>
    /// <param name="proto">Prototype object. Host owns.</param>
    public void SetClassProto(JSContextPointer ctx, JSClassID class_id, JSValuePointer proto)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setClassProto == null)
                throw new InvalidOperationException("HAKO_SetClassProto not available");
            _setClassProto(ctx, class_id, proto);
        });
    }

    /// <summary>Links constructor and prototype (sets .prototype and .constructor)</summary>
    /// <param name="ctx">Context</param>
    /// <param name="constructor">Constructor function. Host owns.</param>
    /// <param name="proto">Prototype object. Host owns.</param>
    public void SetConstructor(JSContextPointer ctx, JSValuePointer constructor, JSValuePointer proto)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setConstructor == null)
                throw new InvalidOperationException("HAKO_SetConstructor not available");
            _setConstructor(ctx, constructor, proto);
        });
    }

    /// <summary>Creates a new instance of a class</summary>
    /// <param name="ctx">Context</param>
    /// <param name="class_id">Class ID</param>
    public JSValuePointer NewObjectClass(JSContextPointer ctx, JSClassID class_id)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newObjectClass == null)
                throw new InvalidOperationException("HAKO_NewObjectClass not available");
            return _newObjectClass(ctx, class_id);
        });
    }

    /// <summary>Sets opaque data on a class instance</summary>
    /// <param name="obj">Object instance. Host owns.</param>
    /// <param name="opaque">Opaque data pointer. Host owns.</param>
    public void SetOpaque(JSValuePointer obj, int opaque)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setOpaque == null)
                throw new InvalidOperationException("HAKO_SetOpaque not available");
            _setOpaque(obj, opaque);
        });
    }

    /// <summary>Gets opaque data from a class instance</summary>
    /// <param name="ctx">Context</param>
    /// <param name="obj">Object instance. Host owns.</param>
    /// <param name="class_id">Expected class ID (for type safety)</param>
    public int GetOpaque(JSContextPointer ctx, JSValuePointer obj, JSClassID class_id)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getOpaque == null)
                throw new InvalidOperationException("HAKO_GetOpaque not available");
            return _getOpaque(ctx, obj, class_id);
        });
    }

    /// <summary>Creates a new object with prototype and class</summary>
    /// <param name="ctx">Context</param>
    /// <param name="proto">Prototype object. Host owns.</param>
    /// <param name="class_id">Class ID</param>
    public JSValuePointer NewObjectProtoClass(JSContextPointer ctx, JSValuePointer proto, JSClassID class_id)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newObjectProtoClass == null)
                throw new InvalidOperationException("HAKO_NewObjectProtoClass not available");
            return _newObjectProtoClass(ctx, proto, class_id);
        });
    }

    /// <summary>Sets a private value on a module</summary>
    /// <param name="ctx">Context</param>
    /// <param name="mod">Module definition</param>
    /// <param name="val">Private value. Caller should free with HAKO_FreeValuePointer after calling.</param>
    public void SetModulePrivateValue(JSContextPointer ctx, JSModuleDefPointer mod, JSValuePointer val)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setModulePrivateValue == null)
                throw new InvalidOperationException("HAKO_SetModulePrivateValue not available");
            _setModulePrivateValue(ctx, mod, val);
        });
    }

    /// <summary>Gets the private value from a module</summary>
    /// <param name="ctx">Context</param>
    /// <param name="mod">Module definition</param>
    public JSValuePointer GetModulePrivateValue(JSContextPointer ctx, JSModuleDefPointer mod)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_getModulePrivateValue == null)
                throw new InvalidOperationException("HAKO_GetModulePrivateValue not available");
            return _getModulePrivateValue(ctx, mod);
        });
    }

    /// <summary>Creates a new typed array with specified length</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="len">Array length (element count)</param>
    /// <param name="type">Typed array type</param>
    public JSValuePointer NewTypedArray(JSContextPointer ctx, int len, int type)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newTypedArray == null)
                throw new InvalidOperationException("HAKO_NewTypedArray not available");
            return _newTypedArray(ctx, len, type);
        });
    }

    /// <summary>Creates a typed array view on an ArrayBuffer</summary>
    /// <param name="ctx">Context to create in</param>
    /// <param name="array_buffer">ArrayBuffer to view</param>
    /// <param name="byte_offset">Byte offset into buffer</param>
    /// <param name="len">Array length (element count)</param>
    /// <param name="type">Typed array type</param>
    public JSValuePointer NewTypedArrayWithBuffer(JSContextPointer ctx, JSValuePointer array_buffer, int byte_offset, int len, int type)
    {
        return Hako.Dispatcher.Invoke(() =>
        {
            if (_newTypedArrayWithBuffer == null)
                throw new InvalidOperationException("HAKO_NewTypedArrayWithBuffer not available");
            return _newTypedArrayWithBuffer(ctx, array_buffer, byte_offset, len, type);
        });
    }

    /// <summary>Runs garbage collection</summary>
    /// <param name="rt">Runtime to run GC on</param>
    public void RunGC(JSRuntimePointer rt)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_runGC == null)
                throw new InvalidOperationException("HAKO_RunGC not available");
            _runGC(rt);
        });
    }

    /// <summary>Marks a JavaScript value during garbage collection</summary>
    /// <param name="rt">Runtime context</param>
    /// <param name="val">Value to mark as reachable. Host owns.</param>
    /// <param name="mark_func">Mark function provided by QuickJS</param>
    public void MarkValue(JSRuntimePointer rt, JSValuePointer val, int mark_func)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_markValue == null)
                throw new InvalidOperationException("HAKO_MarkValue not available");
            _markValue(rt, val, mark_func);
        });
    }

    /// <summary>Sets promise rejection handler for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    /// <param name="opaque">User data passed to host handler. Host borrows.</param>
    public void SetPromiseRejectionHandler(JSRuntimePointer rt, int opaque)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_setPromiseRejectionHandler == null)
                throw new InvalidOperationException("HAKO_SetPromiseRejectionHandler not available");
            _setPromiseRejectionHandler(rt, opaque);
        });
    }

    /// <summary>Clears promise rejection handler for runtime</summary>
    /// <param name="rt">Runtime to configure</param>
    public void ClearPromiseRejectionHandler(JSRuntimePointer rt)
    {
        Hako.Dispatcher.Invoke(() =>
        {
            if (_clearPromiseRejectionHandler == null)
                throw new InvalidOperationException("HAKO_ClearPromiseRejectionHandler not available");
            _clearPromiseRejectionHandler(rt);
        });
    }

    #endregion
}
